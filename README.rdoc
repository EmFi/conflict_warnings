= Conflict_Warnings

conflict_warnings is an ActionController extension that provides methods of
preventing data inconsistencies that could arise from multiple users interacting
with the same resource at roughly the same time. Named after the <b>HTTP 409
Conflict</b> status, conflict_warnings determines if a database conflict is
likely and intercepts potentailly dangerous requests.

= Installation

From the root of your rails project run the following command:

<tt>./script/plugin install git://github.com/EmFi/conflict_warnings.git</tt>

= Usage

Add either +filter_conflicts+ or +filter_resource_conflicts+ to your controllers
as if they were a before filter.

    class ExamplesController < ApplicationController
      filter_conflicts
    end

or

    class ExamplesController < ApplicationController
      filter_resources_conflicts :only => :update
    end

The underlying methods are also provided for use in your own filters, as
+catch_conflict+ and +catch_resource_conflict+.

    class CustomFilterExampleController < ApplicationController
      before_filter :check_lock

      protected
      def check_lock
        unless catch_resources_unavailable :accessor => :unlocked
          acquire_lock
        end
      end
    end

The ConflictWarnings methods will use the options supplied and the params to
select a model in the database and apply an accessor to identify problem requests.

By default the model associated with the controller handling the request is used,
will be used to find the instance with an id of params[:id].

+filter_conflicts+ and +catch_conflicts+ compare a timestamp passed in the link
against the updated_at column of the instance. Helpers are provided for creating
links with this timestamp. If the model was modified after the timestamp, the request
interrupted.

+filter_resources_unavialable+ and +catch_conflicts+ will check for an instance method
that ends with +available+. If this method returns 0 or a false value, the request
is interrupted.

Without any options interrupted requests redirect to the referring request, essentially
reloading the page and any changes.

= Documenation

This plugin comes with generated documentation for its provided methods and classes
in the doc folder.

In depth documentation of +filter_conflicts+ and +filter_resources_unavailable+ can
be found in +ConflictWarnings::ActionController::ClassMethods+. While documentation of
+catch_conflicts+ and +catch_resources_unavaialble+ can be found in
+ConflictWarnigns::ActionController::InstanceMethods+.

+conflict_warnings+ also provides some view helpers, for adding parameters
+catch_conflicts+ require to links. They can be found in
<tt>ConflictWarnings::ActionView::Helpers::UrlHelper</tt>
and <tt>ConflictWarnings::ActionView::Helpers::PrototypeHelper</tt>

= Caveats

If +catch_conflicts+, +catch_resource_conflict+, +filter_conflicts+ and
+filter_resource_conflicts+ not receive enough information to
reach a decision it will usually assumes the action is harmful. Records that produce
a nil value to compare the time the requesting page was rendered will be allowed
to complete successfully.



ActionView::Helpers:
========

link_to_with_timestamp
----------------------

Wrapper for link_to that adds a page_rendered_at=DateTime.now paramater to the
target url.


link_to_remote_with_timestamp
-----------------------------

Wrapper for link_to remote that adds a page_rendered_at=DateTime.now parameter
to the target url.


link_to_remote_with_timestamp_and_fallback
------------------------------------------

Wrapper for link_to_remote_with_timestamp that sets the html_options argument
to link_to_with_timestamp. Allowing for AJAX conflict warnings that successfully
fall back go html requests.


ActionController::Base::Class Methods
=======================================

catch_conflicts and catch_resource_conflict each adds a before_filter call
to a controller class.

Without any arguments, both filters will guess at the information it needs to
to determine if there is a conflict. In the event of a conflict, catch_warnings
will render the template at the views/<controller name>/<action>_conflict for the
requested format. If a template is not found it will fall back to the default
behaviour of redirect_to :back, and setting flash[:warning] to a suitable warning
For JS requests the message is displayed in an alert box.

In the event of a conflict, the requested action is blocked and the filter
either executes the provided block, renders the associated template, or takes
the default action.


Accepted options common to all methods:
-----------------------------------------

:model - ActiveRecord model name that is use to determine if
    there is a conflict. Default value is the taken from the controller name.
    Cannot be used with either :siumlate_conlfict argument.
    
:id - Record id used to determine if there is a conflict. Default value is
    params[options[:params_id_key]]. Cannot be used with either
    :siumlate_conlfict argument.
    
:params_id_key - params hash key linking to the id to be used in conjunction
   with options[:model] an options[:accessor] to determine conflicts.

:find_options - options passed to find, in selecting a record use in identifying
   conflicts. Used only if :params_id_key is not supplied. 
   

:accessor - method in model that returns the value to be used in identifying conflicts.
    In catch_conflicts the default is updated_at or updated_on, if such a column
    exists.
    In catch_resource_conflicts the default is the first column with a name matching /available/.

:template - template file to render in event of a conflict. For catch_conflicts,
    the default value is "#{controller_name}/#{action_name}_conflict". For
    catch_resource_conflicts, the default value is
    "#{controller_name}/#{action_name}_resource_unavailable".
    When a conflict is identified on search for a html.erb, .rhtml,
    or .rjs file depending on the request. If one isn't found the default action
    is taken.

:message - message to add to flash hash. The catch_conflicts default value
    is "Your request will not be processed becasue the data you were viewing is
    out of date. The page has been refreshed. Please try again."
    The catch_resource_conflicts default value is "Your request will not be
    processed because the resource you require is no longer available."

:flash_key - which key of the flash hash to save the message in. Default value
    is :warning

:except, :only - arguments to be passed to the underlying before_filter call

&block - Yielded to respond_to


catch_conflicts(options = {}, &block)
--------------------------------------

catch_conflicts is a helper that creates a before filter using
redirect_if_conflict. catch_conflict compares a timestamp embedded in the 
requested url against a deadline to identify conflicts. Without any arguments, 
the model, id, and accessor are used to select the deadline. Unless options 
dictate otherwise, the model, is taken from the controller name, id is from 
the params[:id] field, and accessor is the updated_at accessor on the instance
of the model with the given id.

If a record cannot be found with the given options, then the request will
proceed without triggering the conflict action.

See the common options for other ways of specifying the deadline.

A conflict is defined by a request after the deadline containing a timestamp 
before the deadline.

Accepted Options:

:time_stamp_key - params hash key containing the timestamp the requesting page was
    rendered. Default value is :page_rendered_at


:simulate_conflict_on_requests_before - instead of dynamically determining
    a deadline to identify conflicts allows you to choose one. Treats all
    requests from pages rendered before this value as a conflict. Default value
    is nil. Useful for enforcing users to take actions following recent
    application updates.

:simulate_conflict_on_requests_after - instead of dynamically determining
    a deadline to identify conflicts allows you to choose one. Treat all
    requests from pages rendered after this value as a conflict. Default value
    is nil. Useful for disabling portions of your application at a specified
    time.



catch_conflicts Example
-----------------

If show is rendered for a record by a user, and another user update's that same
record before the first user clicks the confirm link, catch_conflict will block
the confirm action form happening and seemlessly notify and update the first
user.


--views/sample/show.html.erb--
<div id="warnings">
</div>
<div id="static_content">
...
</div>
<div id="dynamic_content">
    <=%render :partial => dynamic_content%>
</div>
...
<%=link_to_remote_with_timestamp "Confirm", confirm_sample_path(@sample)%>

--controllers/sample_controller_rb--
class SampleController < ApplicationController
    catch_conflicts :only => confirm

    def confirm
        #not executed in a conflict
        ...
    end
    ...
end

--views/sample/confirm_conflict.rjs--
#updates relevant portions of page and highlights changes.
page.replace_html :warning, "We cannot complete your request at this time."
page.replace html :dynamic_content, render :partial => 'sample/dynamic_content'
page.visual_effect :highlight :dynamic_content, :duration => 5

catch_resource_conflict(options = {}, &block)
---------------------------------------------

catch_resource_conflicts is a helper that creates a before filter using
redirect_if_resource_conflict. catch_resourece_conflict  blocks requests 
when a resource is unavailable. 

Without any arguments, the model, id, and accessor are used to
select the resource. Unless options dictate otherwise, the model, is taken from
the controller name, id is from the params[:id] field, and accessor is the first
field containing the name "available" on the instance of the model with the
given id.

If a record cannot be found with the given options, then the request will
proceed without triggering the conflict action.

See the common options for other ways of specifying the deadline.

A conflict is defined by the accessor returning false, or an numeric value of 0
or less.

Accepted Options:

:class_method - Default is nil. If true, accessor is treated as a class method
instead of an instance method. So catch_resource_conflicts will use
model.accessor instead of model.find(id).accessor to identify conflicts.


ActionController::Base::InstanceMethods
========================================

Some times the prepackaged filters do not give you the control you need. So the
methods used to create filters in the class methods are provided for use in
custom filters. 

redirect_if_conflict(options = {}, &block)
-------------------------------------

redirect_if_conflict is intended to be called in a filter. It
compares a timestamp embedded in the requested url against a deadline to 
identify conflicts and redirects/renders the request in the case of a conflict.
Without any arguments, the model, id, and accessor are used 
to select the deadline. Unless options dictate otherwise, the model, is taken 
from the controller name, id is from the params[:id] field, and accessor is the 
updated_at accessor on the instance of the model with the given id.
See the other options for other ways of specifying the deadline.

A conflict is defined by a request after the deadline containing a timestamp 
before the deadline.

Accepted Options:

:time_stamp_key - params hash key containing the timestamp the requesting page was
    rendered. Default value is :page_rendered_at


:simulate_conflict_on_requests_before - instead of dynamically determining
    a deadline to identify conflicts allows you to choose one. Treats all
    requests from pages rendered before this value as a conflict. Default value
    is nil. Useful for enforcing users to take actions following recent
    application updates.

:simulate_conflict_on_requests_after - instead of dynamically determining
    a deadline to identify conflicts allows you to choose one. Treat all
    requests from pages rendered after this value as a conflict. Default value
    is nil. Useful for disabling portions of your application at a specified
    time.



redirect_if_resource_unavailable(options = {}, &block)
----------------------------------------------

redirect_if_conflict is intended to be called in a filter. It
identify conflicts based on the value returned by an accessor
of a model and redirects/renders the request in the case of a conflict.

The model and idfind_options options are used to select the resource.
Unless options dictate otherwise, the model, is taken from
the controller name, id is from the params[:id] field, and accessor is the first
field containing the name "available" on the instance of the model with the
given id.

A conflict is defined by the accessor returning false, or an numeric value of 0
or less.

Accepted Options:

:class_method - Default is nil. If true, accessor is treated as a class method
instead of an instance method. So catch_resource_conflicts will use
model.accessor instead of model.find(id).accessor to identify conflicts.


catch_resource_conflict Example
------------------------------

--views/events/show.html.erb--
<div id="warnings">
</div>
<div id="static_content">
    ...
</div>
<div id="tickets_left">
    There are <%=@event.tickets_left%> tickets available.
</div>
...
<%=link_to_remote "Buy Now", new_event_ticket_path(@event)%>

--controllers/events_controller_rb--
class EventTicketController < ApplicationController
    catch_resources_conflicts :only => :new, :accessor => :tickets_left,
        :model => :event, :params_id_key => :event_id

    def new
        #not executed if event.find(params[:event_id]).tickets_left is false or non positive.
        ...
    end
    ...
end

--views/sample/new_resource_unavailable.rjs--
#updates relevant portions of page and highlights changes.
page.replace_html :warning, "The show you requested has sold out."
page.replace html :tickets_left, render "No tickets available."
page.visual_effect :highlight :tickets_left, :duration => 5





Things To Do:
===========
*Handle additional formats beyond html and js


Copyright (c) 2009 Emery Finkelstein, released under the MIT license
